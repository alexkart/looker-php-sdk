<?php
/**
 * ContentApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Looker API 4.0 Reference
 *
 * API 4.0 is the current release of the Looker API. API 3.1 is deprecated.  ### Authorization  The classic method of API authorization uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page.  API 4.0 adds additional ways to authenticate API requests, including OAuth and CORS requests.  For details, see [Looker API Authorization](https://cloud.google.com/looker/docs/r/api/authorization).   ### API Explorer  The API Explorer is a Looker-provided utility with many new and unique features for learning and using the Looker API and SDKs.  For details, see the [API Explorer documentation](https://cloud.google.com/looker/docs/r/api/explorer).   ### Looker Language SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. SDKs for a variety of programming languages are also provided to streamline using the API. Looker has an OpenSource [sdk-codegen project](https://github.com/looker-open-source/sdk-codegen) that provides several language SDKs. Language SDKs generated by `sdk-codegen` have an Authentication manager that can automatically authenticate API requests when needed.  For details on available Looker SDKs, see [Looker API Client SDKs](https://cloud.google.com/looker/docs/r/api/client_sdks).   ### API Versioning  Future releases of Looker expand the latest API version release-by-release to securely expose more and more of the core power of the Looker platform to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning (but we will try to avoid doing that). Stable (non-beta) API endpoints should not receive breaking changes in future releases.  For details, see [Looker API Versioning](https://cloud.google.com/looker/docs/r/api/versioning).   ### In This Release  API 4.0 version was introduced to make adjustments to API functions, parameters, and response types to fix bugs and inconsistencies. These changes fall outside the bounds of non-breaking additive changes we can make to the previous API 3.1.  One benefit of these type adjustments in API 4.0 is dramatically better support for strongly typed languages like TypeScript, Kotlin, Swift, Go, C#, and more.  See the [API 4.0 GA announcement](https://developers.looker.com/api/advanced-usage/version-4-ga) for more information about API 4.0.  The API Explorer can be used to [interactively compare](https://cloud.google.com/looker/docs/r/api/explorer#comparing_api_versions) the differences between API 3.1 and 4.0.   ### API and SDK Support Policies  Looker API versions and language SDKs have varying support levels. Please read the API and SDK [support policies](https://cloud.google.com/looker/docs/r/api/support-policy) for more information.
 *
 * OpenAPI spec version: 4.0.23.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.32
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ContentApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ContentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation allContentMetadataAccesses
     *
     * Get All Content Metadata Accesses
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentMetaGroupUser[]
     */
    public function allContentMetadataAccesses($content_metadata_id, $fields = null)
    {
        list($response) = $this->allContentMetadataAccessesWithHttpInfo($content_metadata_id, $fields);
        return $response;
    }

    /**
     * Operation allContentMetadataAccessesWithHttpInfo
     *
     * Get All Content Metadata Accesses
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentMetaGroupUser[], HTTP status code, HTTP response headers (array of strings)
     */
    public function allContentMetadataAccessesWithHttpInfo($content_metadata_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentMetaGroupUser[]';
        $request = $this->allContentMetadataAccessesRequest($content_metadata_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentMetaGroupUser[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation allContentMetadataAccessesAsync
     *
     * Get All Content Metadata Accesses
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allContentMetadataAccessesAsync($content_metadata_id, $fields = null)
    {
        return $this->allContentMetadataAccessesAsyncWithHttpInfo($content_metadata_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation allContentMetadataAccessesAsyncWithHttpInfo
     *
     * Get All Content Metadata Accesses
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allContentMetadataAccessesAsyncWithHttpInfo($content_metadata_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentMetaGroupUser[]';
        $request = $this->allContentMetadataAccessesRequest($content_metadata_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'allContentMetadataAccesses'
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function allContentMetadataAccessesRequest($content_metadata_id, $fields = null)
    {
        // verify the required parameter 'content_metadata_id' is set
        if ($content_metadata_id === null || (is_array($content_metadata_id) && count($content_metadata_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_metadata_id when calling allContentMetadataAccesses'
            );
        }

        $resourcePath = '/content_metadata_access';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($content_metadata_id !== null) {
            $queryParams['content_metadata_id'] = ObjectSerializer::toQueryValue($content_metadata_id);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation allContentMetadatas
     *
     * Get All Content Metadatas
     *
     * @param  string $parent_id Parent space of content. (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentMeta[]
     */
    public function allContentMetadatas($parent_id, $fields = null)
    {
        list($response) = $this->allContentMetadatasWithHttpInfo($parent_id, $fields);
        return $response;
    }

    /**
     * Operation allContentMetadatasWithHttpInfo
     *
     * Get All Content Metadatas
     *
     * @param  string $parent_id Parent space of content. (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentMeta[], HTTP status code, HTTP response headers (array of strings)
     */
    public function allContentMetadatasWithHttpInfo($parent_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentMeta[]';
        $request = $this->allContentMetadatasRequest($parent_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentMeta[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation allContentMetadatasAsync
     *
     * Get All Content Metadatas
     *
     * @param  string $parent_id Parent space of content. (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allContentMetadatasAsync($parent_id, $fields = null)
    {
        return $this->allContentMetadatasAsyncWithHttpInfo($parent_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation allContentMetadatasAsyncWithHttpInfo
     *
     * Get All Content Metadatas
     *
     * @param  string $parent_id Parent space of content. (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allContentMetadatasAsyncWithHttpInfo($parent_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentMeta[]';
        $request = $this->allContentMetadatasRequest($parent_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'allContentMetadatas'
     *
     * @param  string $parent_id Parent space of content. (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function allContentMetadatasRequest($parent_id, $fields = null)
    {
        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling allContentMetadatas'
            );
        }

        $resourcePath = '/content_metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($parent_id !== null) {
            $queryParams['parent_id'] = ObjectSerializer::toQueryValue($parent_id);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation contentFavorite
     *
     * Get Favorite Content
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentFavorite
     */
    public function contentFavorite($content_favorite_id, $fields = null)
    {
        list($response) = $this->contentFavoriteWithHttpInfo($content_favorite_id, $fields);
        return $response;
    }

    /**
     * Operation contentFavoriteWithHttpInfo
     *
     * Get Favorite Content
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentFavorite, HTTP status code, HTTP response headers (array of strings)
     */
    public function contentFavoriteWithHttpInfo($content_favorite_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentFavorite';
        $request = $this->contentFavoriteRequest($content_favorite_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentFavorite',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation contentFavoriteAsync
     *
     * Get Favorite Content
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contentFavoriteAsync($content_favorite_id, $fields = null)
    {
        return $this->contentFavoriteAsyncWithHttpInfo($content_favorite_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation contentFavoriteAsyncWithHttpInfo
     *
     * Get Favorite Content
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contentFavoriteAsyncWithHttpInfo($content_favorite_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentFavorite';
        $request = $this->contentFavoriteRequest($content_favorite_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'contentFavorite'
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function contentFavoriteRequest($content_favorite_id, $fields = null)
    {
        // verify the required parameter 'content_favorite_id' is set
        if ($content_favorite_id === null || (is_array($content_favorite_id) && count($content_favorite_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_favorite_id when calling contentFavorite'
            );
        }

        $resourcePath = '/content_favorite/{content_favorite_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($content_favorite_id !== null) {
            $resourcePath = str_replace(
                '{' . 'content_favorite_id' . '}',
                ObjectSerializer::toPathValue($content_favorite_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation contentMetadata
     *
     * Get Content Metadata
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentMeta
     */
    public function contentMetadata($content_metadata_id, $fields = null)
    {
        list($response) = $this->contentMetadataWithHttpInfo($content_metadata_id, $fields);
        return $response;
    }

    /**
     * Operation contentMetadataWithHttpInfo
     *
     * Get Content Metadata
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentMeta, HTTP status code, HTTP response headers (array of strings)
     */
    public function contentMetadataWithHttpInfo($content_metadata_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentMeta';
        $request = $this->contentMetadataRequest($content_metadata_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentMeta',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation contentMetadataAsync
     *
     * Get Content Metadata
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contentMetadataAsync($content_metadata_id, $fields = null)
    {
        return $this->contentMetadataAsyncWithHttpInfo($content_metadata_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation contentMetadataAsyncWithHttpInfo
     *
     * Get Content Metadata
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contentMetadataAsyncWithHttpInfo($content_metadata_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentMeta';
        $request = $this->contentMetadataRequest($content_metadata_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'contentMetadata'
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function contentMetadataRequest($content_metadata_id, $fields = null)
    {
        // verify the required parameter 'content_metadata_id' is set
        if ($content_metadata_id === null || (is_array($content_metadata_id) && count($content_metadata_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_metadata_id when calling contentMetadata'
            );
        }

        $resourcePath = '/content_metadata/{content_metadata_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($content_metadata_id !== null) {
            $resourcePath = str_replace(
                '{' . 'content_metadata_id' . '}',
                ObjectSerializer::toPathValue($content_metadata_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation contentThumbnail
     *
     * Get Content Thumbnail
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     * @param  string $format A value of png produces a thumbnail in PNG format instead of SVG (default) (optional)
     * @param  int $width The width of the image if format is supplied (optional)
     * @param  int $height The height of the image if format is supplied (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function contentThumbnail($type, $resource_id, $reload = null, $format = null, $width = null, $height = null)
    {
        list($response) = $this->contentThumbnailWithHttpInfo($type, $resource_id, $reload, $format, $width, $height);
        return $response;
    }

    /**
     * Operation contentThumbnailWithHttpInfo
     *
     * Get Content Thumbnail
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     * @param  string $format A value of png produces a thumbnail in PNG format instead of SVG (default) (optional)
     * @param  int $width The width of the image if format is supplied (optional)
     * @param  int $height The height of the image if format is supplied (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function contentThumbnailWithHttpInfo($type, $resource_id, $reload = null, $format = null, $width = null, $height = null)
    {
        $returnType = 'string';
        $request = $this->contentThumbnailRequest($type, $resource_id, $reload, $format, $width, $height);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation contentThumbnailAsync
     *
     * Get Content Thumbnail
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     * @param  string $format A value of png produces a thumbnail in PNG format instead of SVG (default) (optional)
     * @param  int $width The width of the image if format is supplied (optional)
     * @param  int $height The height of the image if format is supplied (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contentThumbnailAsync($type, $resource_id, $reload = null, $format = null, $width = null, $height = null)
    {
        return $this->contentThumbnailAsyncWithHttpInfo($type, $resource_id, $reload, $format, $width, $height)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation contentThumbnailAsyncWithHttpInfo
     *
     * Get Content Thumbnail
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     * @param  string $format A value of png produces a thumbnail in PNG format instead of SVG (default) (optional)
     * @param  int $width The width of the image if format is supplied (optional)
     * @param  int $height The height of the image if format is supplied (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contentThumbnailAsyncWithHttpInfo($type, $resource_id, $reload = null, $format = null, $width = null, $height = null)
    {
        $returnType = 'string';
        $request = $this->contentThumbnailRequest($type, $resource_id, $reload, $format, $width, $height);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'contentThumbnail'
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     * @param  string $format A value of png produces a thumbnail in PNG format instead of SVG (default) (optional)
     * @param  int $width The width of the image if format is supplied (optional)
     * @param  int $height The height of the image if format is supplied (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function contentThumbnailRequest($type, $resource_id, $reload = null, $format = null, $width = null, $height = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling contentThumbnail'
            );
        }
        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling contentThumbnail'
            );
        }

        $resourcePath = '/content_thumbnail/{type}/{resource_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($reload !== null) {
            $queryParams['reload'] = ObjectSerializer::toQueryValue($reload);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width);
        }
        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height);
        }

        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resource_id' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/svg+xml', 'image/png']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/svg+xml', 'image/png'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation contentValidation
     *
     * Validate Content
     *
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentValidation
     */
    public function contentValidation($fields = null)
    {
        list($response) = $this->contentValidationWithHttpInfo($fields);
        return $response;
    }

    /**
     * Operation contentValidationWithHttpInfo
     *
     * Validate Content
     *
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentValidation, HTTP status code, HTTP response headers (array of strings)
     */
    public function contentValidationWithHttpInfo($fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentValidation';
        $request = $this->contentValidationRequest($fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentValidation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation contentValidationAsync
     *
     * Validate Content
     *
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contentValidationAsync($fields = null)
    {
        return $this->contentValidationAsyncWithHttpInfo($fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation contentValidationAsyncWithHttpInfo
     *
     * Validate Content
     *
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function contentValidationAsyncWithHttpInfo($fields = null)
    {
        $returnType = '\Swagger\Client\Model\ContentValidation';
        $request = $this->contentValidationRequest($fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'contentValidation'
     *
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function contentValidationRequest($fields = null)
    {

        $resourcePath = '/content_validation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createContentFavorite
     *
     * Create Favorite Content
     *
     * @param  \Swagger\Client\Model\ContentFavorite $body Favorite Content (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentFavorite
     */
    public function createContentFavorite($body)
    {
        list($response) = $this->createContentFavoriteWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createContentFavoriteWithHttpInfo
     *
     * Create Favorite Content
     *
     * @param  \Swagger\Client\Model\ContentFavorite $body Favorite Content (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentFavorite, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContentFavoriteWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ContentFavorite';
        $request = $this->createContentFavoriteRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentFavorite',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createContentFavoriteAsync
     *
     * Create Favorite Content
     *
     * @param  \Swagger\Client\Model\ContentFavorite $body Favorite Content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContentFavoriteAsync($body)
    {
        return $this->createContentFavoriteAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContentFavoriteAsyncWithHttpInfo
     *
     * Create Favorite Content
     *
     * @param  \Swagger\Client\Model\ContentFavorite $body Favorite Content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContentFavoriteAsyncWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\ContentFavorite';
        $request = $this->createContentFavoriteRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContentFavorite'
     *
     * @param  \Swagger\Client\Model\ContentFavorite $body Favorite Content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createContentFavoriteRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createContentFavorite'
            );
        }

        $resourcePath = '/content_favorite';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createContentMetadataAccess
     *
     * Create Content Metadata Access
     *
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     * @param  bool $send_boards_notification_email Optionally sends notification email when granting access to a board. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentMetaGroupUser
     */
    public function createContentMetadataAccess($body, $send_boards_notification_email = null)
    {
        list($response) = $this->createContentMetadataAccessWithHttpInfo($body, $send_boards_notification_email);
        return $response;
    }

    /**
     * Operation createContentMetadataAccessWithHttpInfo
     *
     * Create Content Metadata Access
     *
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     * @param  bool $send_boards_notification_email Optionally sends notification email when granting access to a board. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentMetaGroupUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContentMetadataAccessWithHttpInfo($body, $send_boards_notification_email = null)
    {
        $returnType = '\Swagger\Client\Model\ContentMetaGroupUser';
        $request = $this->createContentMetadataAccessRequest($body, $send_boards_notification_email);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentMetaGroupUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createContentMetadataAccessAsync
     *
     * Create Content Metadata Access
     *
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     * @param  bool $send_boards_notification_email Optionally sends notification email when granting access to a board. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContentMetadataAccessAsync($body, $send_boards_notification_email = null)
    {
        return $this->createContentMetadataAccessAsyncWithHttpInfo($body, $send_boards_notification_email)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContentMetadataAccessAsyncWithHttpInfo
     *
     * Create Content Metadata Access
     *
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     * @param  bool $send_boards_notification_email Optionally sends notification email when granting access to a board. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createContentMetadataAccessAsyncWithHttpInfo($body, $send_boards_notification_email = null)
    {
        $returnType = '\Swagger\Client\Model\ContentMetaGroupUser';
        $request = $this->createContentMetadataAccessRequest($body, $send_boards_notification_email);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContentMetadataAccess'
     *
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     * @param  bool $send_boards_notification_email Optionally sends notification email when granting access to a board. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createContentMetadataAccessRequest($body, $send_boards_notification_email = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createContentMetadataAccess'
            );
        }

        $resourcePath = '/content_metadata_access';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($send_boards_notification_email !== null) {
            $queryParams['send_boards_notification_email'] = ObjectSerializer::toQueryValue($send_boards_notification_email);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContentFavorite
     *
     * Delete Favorite Content
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function deleteContentFavorite($content_favorite_id)
    {
        list($response) = $this->deleteContentFavoriteWithHttpInfo($content_favorite_id);
        return $response;
    }

    /**
     * Operation deleteContentFavoriteWithHttpInfo
     *
     * Delete Favorite Content
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContentFavoriteWithHttpInfo($content_favorite_id)
    {
        $returnType = 'string';
        $request = $this->deleteContentFavoriteRequest($content_favorite_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteContentFavoriteAsync
     *
     * Delete Favorite Content
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContentFavoriteAsync($content_favorite_id)
    {
        return $this->deleteContentFavoriteAsyncWithHttpInfo($content_favorite_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContentFavoriteAsyncWithHttpInfo
     *
     * Delete Favorite Content
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContentFavoriteAsyncWithHttpInfo($content_favorite_id)
    {
        $returnType = 'string';
        $request = $this->deleteContentFavoriteRequest($content_favorite_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContentFavorite'
     *
     * @param  string $content_favorite_id Id of favorite content (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteContentFavoriteRequest($content_favorite_id)
    {
        // verify the required parameter 'content_favorite_id' is set
        if ($content_favorite_id === null || (is_array($content_favorite_id) && count($content_favorite_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_favorite_id when calling deleteContentFavorite'
            );
        }

        $resourcePath = '/content_favorite/{content_favorite_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($content_favorite_id !== null) {
            $resourcePath = str_replace(
                '{' . 'content_favorite_id' . '}',
                ObjectSerializer::toPathValue($content_favorite_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContentMetadataAccess
     *
     * Delete Content Metadata Access
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function deleteContentMetadataAccess($content_metadata_access_id)
    {
        list($response) = $this->deleteContentMetadataAccessWithHttpInfo($content_metadata_access_id);
        return $response;
    }

    /**
     * Operation deleteContentMetadataAccessWithHttpInfo
     *
     * Delete Content Metadata Access
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContentMetadataAccessWithHttpInfo($content_metadata_access_id)
    {
        $returnType = 'string';
        $request = $this->deleteContentMetadataAccessRequest($content_metadata_access_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteContentMetadataAccessAsync
     *
     * Delete Content Metadata Access
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContentMetadataAccessAsync($content_metadata_access_id)
    {
        return $this->deleteContentMetadataAccessAsyncWithHttpInfo($content_metadata_access_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContentMetadataAccessAsyncWithHttpInfo
     *
     * Delete Content Metadata Access
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteContentMetadataAccessAsyncWithHttpInfo($content_metadata_access_id)
    {
        $returnType = 'string';
        $request = $this->deleteContentMetadataAccessRequest($content_metadata_access_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContentMetadataAccess'
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteContentMetadataAccessRequest($content_metadata_access_id)
    {
        // verify the required parameter 'content_metadata_access_id' is set
        if ($content_metadata_access_id === null || (is_array($content_metadata_access_id) && count($content_metadata_access_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_metadata_access_id when calling deleteContentMetadataAccess'
            );
        }

        $resourcePath = '/content_metadata_access/{content_metadata_access_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($content_metadata_access_id !== null) {
            $resourcePath = str_replace(
                '{' . 'content_metadata_access_id' . '}',
                ObjectSerializer::toPathValue($content_metadata_access_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchContentFavorites
     *
     * Search Favorite Contents
     *
     * @param  string $id Match content favorite id(s) (optional)
     * @param  string $user_id Match user id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $content_metadata_id Match content metadata id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $dashboard_id Match dashboard id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $look_id Match look id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $board_id Match board id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  int $limit Number of results to return. (used with offset) (optional)
     * @param  int $offset Number of results to skip before returning any. (used with limit) (optional)
     * @param  string $sorts Fields to sort by. (optional)
     * @param  string $fields Requested fields. (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentFavorite[]
     */
    public function searchContentFavorites($id = null, $user_id = null, $content_metadata_id = null, $dashboard_id = null, $look_id = null, $board_id = null, $limit = null, $offset = null, $sorts = null, $fields = null, $filter_or = null)
    {
        list($response) = $this->searchContentFavoritesWithHttpInfo($id, $user_id, $content_metadata_id, $dashboard_id, $look_id, $board_id, $limit, $offset, $sorts, $fields, $filter_or);
        return $response;
    }

    /**
     * Operation searchContentFavoritesWithHttpInfo
     *
     * Search Favorite Contents
     *
     * @param  string $id Match content favorite id(s) (optional)
     * @param  string $user_id Match user id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $content_metadata_id Match content metadata id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $dashboard_id Match dashboard id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $look_id Match look id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $board_id Match board id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  int $limit Number of results to return. (used with offset) (optional)
     * @param  int $offset Number of results to skip before returning any. (used with limit) (optional)
     * @param  string $sorts Fields to sort by. (optional)
     * @param  string $fields Requested fields. (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentFavorite[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchContentFavoritesWithHttpInfo($id = null, $user_id = null, $content_metadata_id = null, $dashboard_id = null, $look_id = null, $board_id = null, $limit = null, $offset = null, $sorts = null, $fields = null, $filter_or = null)
    {
        $returnType = '\Swagger\Client\Model\ContentFavorite[]';
        $request = $this->searchContentFavoritesRequest($id, $user_id, $content_metadata_id, $dashboard_id, $look_id, $board_id, $limit, $offset, $sorts, $fields, $filter_or);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentFavorite[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchContentFavoritesAsync
     *
     * Search Favorite Contents
     *
     * @param  string $id Match content favorite id(s) (optional)
     * @param  string $user_id Match user id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $content_metadata_id Match content metadata id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $dashboard_id Match dashboard id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $look_id Match look id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $board_id Match board id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  int $limit Number of results to return. (used with offset) (optional)
     * @param  int $offset Number of results to skip before returning any. (used with limit) (optional)
     * @param  string $sorts Fields to sort by. (optional)
     * @param  string $fields Requested fields. (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchContentFavoritesAsync($id = null, $user_id = null, $content_metadata_id = null, $dashboard_id = null, $look_id = null, $board_id = null, $limit = null, $offset = null, $sorts = null, $fields = null, $filter_or = null)
    {
        return $this->searchContentFavoritesAsyncWithHttpInfo($id, $user_id, $content_metadata_id, $dashboard_id, $look_id, $board_id, $limit, $offset, $sorts, $fields, $filter_or)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchContentFavoritesAsyncWithHttpInfo
     *
     * Search Favorite Contents
     *
     * @param  string $id Match content favorite id(s) (optional)
     * @param  string $user_id Match user id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $content_metadata_id Match content metadata id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $dashboard_id Match dashboard id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $look_id Match look id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $board_id Match board id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  int $limit Number of results to return. (used with offset) (optional)
     * @param  int $offset Number of results to skip before returning any. (used with limit) (optional)
     * @param  string $sorts Fields to sort by. (optional)
     * @param  string $fields Requested fields. (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchContentFavoritesAsyncWithHttpInfo($id = null, $user_id = null, $content_metadata_id = null, $dashboard_id = null, $look_id = null, $board_id = null, $limit = null, $offset = null, $sorts = null, $fields = null, $filter_or = null)
    {
        $returnType = '\Swagger\Client\Model\ContentFavorite[]';
        $request = $this->searchContentFavoritesRequest($id, $user_id, $content_metadata_id, $dashboard_id, $look_id, $board_id, $limit, $offset, $sorts, $fields, $filter_or);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchContentFavorites'
     *
     * @param  string $id Match content favorite id(s) (optional)
     * @param  string $user_id Match user id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $content_metadata_id Match content metadata id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $dashboard_id Match dashboard id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $look_id Match look id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  string $board_id Match board id(s).To create a list of multiple ids, use commas as separators (optional)
     * @param  int $limit Number of results to return. (used with offset) (optional)
     * @param  int $offset Number of results to skip before returning any. (used with limit) (optional)
     * @param  string $sorts Fields to sort by. (optional)
     * @param  string $fields Requested fields. (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchContentFavoritesRequest($id = null, $user_id = null, $content_metadata_id = null, $dashboard_id = null, $look_id = null, $board_id = null, $limit = null, $offset = null, $sorts = null, $fields = null, $filter_or = null)
    {

        $resourcePath = '/content_favorite/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['user_id'] = ObjectSerializer::toQueryValue($user_id);
        }
        // query params
        if ($content_metadata_id !== null) {
            $queryParams['content_metadata_id'] = ObjectSerializer::toQueryValue($content_metadata_id);
        }
        // query params
        if ($dashboard_id !== null) {
            $queryParams['dashboard_id'] = ObjectSerializer::toQueryValue($dashboard_id);
        }
        // query params
        if ($look_id !== null) {
            $queryParams['look_id'] = ObjectSerializer::toQueryValue($look_id);
        }
        // query params
        if ($board_id !== null) {
            $queryParams['board_id'] = ObjectSerializer::toQueryValue($board_id);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($sorts !== null) {
            $queryParams['sorts'] = ObjectSerializer::toQueryValue($sorts);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($filter_or !== null) {
            $queryParams['filter_or'] = ObjectSerializer::toQueryValue($filter_or);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchContentViews
     *
     * Search Content Views
     *
     * @param  string $view_count Match view count (optional)
     * @param  string $group_id Match Group Id (optional)
     * @param  string $look_id Match look_id (optional)
     * @param  string $dashboard_id Match dashboard_id (optional)
     * @param  string $content_metadata_id Match content metadata id (optional)
     * @param  string $start_of_week_date Match start of week date (format is \&quot;YYYY-MM-DD\&quot;) (optional)
     * @param  bool $all_time True if only all time view records should be returned (optional)
     * @param  string $user_id Match user id (optional)
     * @param  string $fields Requested fields (optional)
     * @param  int $limit Number of results to return. Use with &#x60;offset&#x60; to manage pagination of results (optional)
     * @param  int $offset Number of results to skip before returning data (optional)
     * @param  string $sorts Fields to sort by (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentView[]
     */
    public function searchContentViews($view_count = null, $group_id = null, $look_id = null, $dashboard_id = null, $content_metadata_id = null, $start_of_week_date = null, $all_time = null, $user_id = null, $fields = null, $limit = null, $offset = null, $sorts = null, $filter_or = null)
    {
        list($response) = $this->searchContentViewsWithHttpInfo($view_count, $group_id, $look_id, $dashboard_id, $content_metadata_id, $start_of_week_date, $all_time, $user_id, $fields, $limit, $offset, $sorts, $filter_or);
        return $response;
    }

    /**
     * Operation searchContentViewsWithHttpInfo
     *
     * Search Content Views
     *
     * @param  string $view_count Match view count (optional)
     * @param  string $group_id Match Group Id (optional)
     * @param  string $look_id Match look_id (optional)
     * @param  string $dashboard_id Match dashboard_id (optional)
     * @param  string $content_metadata_id Match content metadata id (optional)
     * @param  string $start_of_week_date Match start of week date (format is \&quot;YYYY-MM-DD\&quot;) (optional)
     * @param  bool $all_time True if only all time view records should be returned (optional)
     * @param  string $user_id Match user id (optional)
     * @param  string $fields Requested fields (optional)
     * @param  int $limit Number of results to return. Use with &#x60;offset&#x60; to manage pagination of results (optional)
     * @param  int $offset Number of results to skip before returning data (optional)
     * @param  string $sorts Fields to sort by (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentView[], HTTP status code, HTTP response headers (array of strings)
     */
    public function searchContentViewsWithHttpInfo($view_count = null, $group_id = null, $look_id = null, $dashboard_id = null, $content_metadata_id = null, $start_of_week_date = null, $all_time = null, $user_id = null, $fields = null, $limit = null, $offset = null, $sorts = null, $filter_or = null)
    {
        $returnType = '\Swagger\Client\Model\ContentView[]';
        $request = $this->searchContentViewsRequest($view_count, $group_id, $look_id, $dashboard_id, $content_metadata_id, $start_of_week_date, $all_time, $user_id, $fields, $limit, $offset, $sorts, $filter_or);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentView[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchContentViewsAsync
     *
     * Search Content Views
     *
     * @param  string $view_count Match view count (optional)
     * @param  string $group_id Match Group Id (optional)
     * @param  string $look_id Match look_id (optional)
     * @param  string $dashboard_id Match dashboard_id (optional)
     * @param  string $content_metadata_id Match content metadata id (optional)
     * @param  string $start_of_week_date Match start of week date (format is \&quot;YYYY-MM-DD\&quot;) (optional)
     * @param  bool $all_time True if only all time view records should be returned (optional)
     * @param  string $user_id Match user id (optional)
     * @param  string $fields Requested fields (optional)
     * @param  int $limit Number of results to return. Use with &#x60;offset&#x60; to manage pagination of results (optional)
     * @param  int $offset Number of results to skip before returning data (optional)
     * @param  string $sorts Fields to sort by (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchContentViewsAsync($view_count = null, $group_id = null, $look_id = null, $dashboard_id = null, $content_metadata_id = null, $start_of_week_date = null, $all_time = null, $user_id = null, $fields = null, $limit = null, $offset = null, $sorts = null, $filter_or = null)
    {
        return $this->searchContentViewsAsyncWithHttpInfo($view_count, $group_id, $look_id, $dashboard_id, $content_metadata_id, $start_of_week_date, $all_time, $user_id, $fields, $limit, $offset, $sorts, $filter_or)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchContentViewsAsyncWithHttpInfo
     *
     * Search Content Views
     *
     * @param  string $view_count Match view count (optional)
     * @param  string $group_id Match Group Id (optional)
     * @param  string $look_id Match look_id (optional)
     * @param  string $dashboard_id Match dashboard_id (optional)
     * @param  string $content_metadata_id Match content metadata id (optional)
     * @param  string $start_of_week_date Match start of week date (format is \&quot;YYYY-MM-DD\&quot;) (optional)
     * @param  bool $all_time True if only all time view records should be returned (optional)
     * @param  string $user_id Match user id (optional)
     * @param  string $fields Requested fields (optional)
     * @param  int $limit Number of results to return. Use with &#x60;offset&#x60; to manage pagination of results (optional)
     * @param  int $offset Number of results to skip before returning data (optional)
     * @param  string $sorts Fields to sort by (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchContentViewsAsyncWithHttpInfo($view_count = null, $group_id = null, $look_id = null, $dashboard_id = null, $content_metadata_id = null, $start_of_week_date = null, $all_time = null, $user_id = null, $fields = null, $limit = null, $offset = null, $sorts = null, $filter_or = null)
    {
        $returnType = '\Swagger\Client\Model\ContentView[]';
        $request = $this->searchContentViewsRequest($view_count, $group_id, $look_id, $dashboard_id, $content_metadata_id, $start_of_week_date, $all_time, $user_id, $fields, $limit, $offset, $sorts, $filter_or);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchContentViews'
     *
     * @param  string $view_count Match view count (optional)
     * @param  string $group_id Match Group Id (optional)
     * @param  string $look_id Match look_id (optional)
     * @param  string $dashboard_id Match dashboard_id (optional)
     * @param  string $content_metadata_id Match content metadata id (optional)
     * @param  string $start_of_week_date Match start of week date (format is \&quot;YYYY-MM-DD\&quot;) (optional)
     * @param  bool $all_time True if only all time view records should be returned (optional)
     * @param  string $user_id Match user id (optional)
     * @param  string $fields Requested fields (optional)
     * @param  int $limit Number of results to return. Use with &#x60;offset&#x60; to manage pagination of results (optional)
     * @param  int $offset Number of results to skip before returning data (optional)
     * @param  string $sorts Fields to sort by (optional)
     * @param  bool $filter_or Combine given search criteria in a boolean OR expression (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchContentViewsRequest($view_count = null, $group_id = null, $look_id = null, $dashboard_id = null, $content_metadata_id = null, $start_of_week_date = null, $all_time = null, $user_id = null, $fields = null, $limit = null, $offset = null, $sorts = null, $filter_or = null)
    {

        $resourcePath = '/content_view/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($view_count !== null) {
            $queryParams['view_count'] = ObjectSerializer::toQueryValue($view_count);
        }
        // query params
        if ($group_id !== null) {
            $queryParams['group_id'] = ObjectSerializer::toQueryValue($group_id);
        }
        // query params
        if ($look_id !== null) {
            $queryParams['look_id'] = ObjectSerializer::toQueryValue($look_id);
        }
        // query params
        if ($dashboard_id !== null) {
            $queryParams['dashboard_id'] = ObjectSerializer::toQueryValue($dashboard_id);
        }
        // query params
        if ($content_metadata_id !== null) {
            $queryParams['content_metadata_id'] = ObjectSerializer::toQueryValue($content_metadata_id);
        }
        // query params
        if ($start_of_week_date !== null) {
            $queryParams['start_of_week_date'] = ObjectSerializer::toQueryValue($start_of_week_date);
        }
        // query params
        if ($all_time !== null) {
            $queryParams['all_time'] = ObjectSerializer::toQueryValue($all_time);
        }
        // query params
        if ($user_id !== null) {
            $queryParams['user_id'] = ObjectSerializer::toQueryValue($user_id);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($sorts !== null) {
            $queryParams['sorts'] = ObjectSerializer::toQueryValue($sorts);
        }
        // query params
        if ($filter_or !== null) {
            $queryParams['filter_or'] = ObjectSerializer::toQueryValue($filter_or);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContentMetadata
     *
     * Update Content Metadata
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  \Swagger\Client\Model\ContentMeta $body Content Metadata (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentMeta
     */
    public function updateContentMetadata($content_metadata_id, $body)
    {
        list($response) = $this->updateContentMetadataWithHttpInfo($content_metadata_id, $body);
        return $response;
    }

    /**
     * Operation updateContentMetadataWithHttpInfo
     *
     * Update Content Metadata
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  \Swagger\Client\Model\ContentMeta $body Content Metadata (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentMeta, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContentMetadataWithHttpInfo($content_metadata_id, $body)
    {
        $returnType = '\Swagger\Client\Model\ContentMeta';
        $request = $this->updateContentMetadataRequest($content_metadata_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentMeta',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateContentMetadataAsync
     *
     * Update Content Metadata
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  \Swagger\Client\Model\ContentMeta $body Content Metadata (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContentMetadataAsync($content_metadata_id, $body)
    {
        return $this->updateContentMetadataAsyncWithHttpInfo($content_metadata_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContentMetadataAsyncWithHttpInfo
     *
     * Update Content Metadata
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  \Swagger\Client\Model\ContentMeta $body Content Metadata (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContentMetadataAsyncWithHttpInfo($content_metadata_id, $body)
    {
        $returnType = '\Swagger\Client\Model\ContentMeta';
        $request = $this->updateContentMetadataRequest($content_metadata_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContentMetadata'
     *
     * @param  string $content_metadata_id Id of content metadata (required)
     * @param  \Swagger\Client\Model\ContentMeta $body Content Metadata (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateContentMetadataRequest($content_metadata_id, $body)
    {
        // verify the required parameter 'content_metadata_id' is set
        if ($content_metadata_id === null || (is_array($content_metadata_id) && count($content_metadata_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_metadata_id when calling updateContentMetadata'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateContentMetadata'
            );
        }

        $resourcePath = '/content_metadata/{content_metadata_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($content_metadata_id !== null) {
            $resourcePath = str_replace(
                '{' . 'content_metadata_id' . '}',
                ObjectSerializer::toPathValue($content_metadata_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContentMetadataAccess
     *
     * Update Content Metadata Access
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ContentMetaGroupUser
     */
    public function updateContentMetadataAccess($content_metadata_access_id, $body)
    {
        list($response) = $this->updateContentMetadataAccessWithHttpInfo($content_metadata_access_id, $body);
        return $response;
    }

    /**
     * Operation updateContentMetadataAccessWithHttpInfo
     *
     * Update Content Metadata Access
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ContentMetaGroupUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContentMetadataAccessWithHttpInfo($content_metadata_access_id, $body)
    {
        $returnType = '\Swagger\Client\Model\ContentMetaGroupUser';
        $request = $this->updateContentMetadataAccessRequest($content_metadata_access_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ContentMetaGroupUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateContentMetadataAccessAsync
     *
     * Update Content Metadata Access
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContentMetadataAccessAsync($content_metadata_access_id, $body)
    {
        return $this->updateContentMetadataAccessAsyncWithHttpInfo($content_metadata_access_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContentMetadataAccessAsyncWithHttpInfo
     *
     * Update Content Metadata Access
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateContentMetadataAccessAsyncWithHttpInfo($content_metadata_access_id, $body)
    {
        $returnType = '\Swagger\Client\Model\ContentMetaGroupUser';
        $request = $this->updateContentMetadataAccessRequest($content_metadata_access_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContentMetadataAccess'
     *
     * @param  string $content_metadata_access_id Id of content metadata access (required)
     * @param  \Swagger\Client\Model\ContentMetaGroupUser $body Content Metadata Access (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateContentMetadataAccessRequest($content_metadata_access_id, $body)
    {
        // verify the required parameter 'content_metadata_access_id' is set
        if ($content_metadata_access_id === null || (is_array($content_metadata_access_id) && count($content_metadata_access_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_metadata_access_id when calling updateContentMetadataAccess'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateContentMetadataAccess'
            );
        }

        $resourcePath = '/content_metadata_access/{content_metadata_access_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($content_metadata_access_id !== null) {
            $resourcePath = str_replace(
                '{' . 'content_metadata_access_id' . '}',
                ObjectSerializer::toPathValue($content_metadata_access_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vectorThumbnail
     *
     * Get Vector Thumbnail
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function vectorThumbnail($type, $resource_id, $reload = null)
    {
        list($response) = $this->vectorThumbnailWithHttpInfo($type, $resource_id, $reload);
        return $response;
    }

    /**
     * Operation vectorThumbnailWithHttpInfo
     *
     * Get Vector Thumbnail
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function vectorThumbnailWithHttpInfo($type, $resource_id, $reload = null)
    {
        $returnType = 'string';
        $request = $this->vectorThumbnailRequest($type, $resource_id, $reload);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vectorThumbnailAsync
     *
     * Get Vector Thumbnail
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vectorThumbnailAsync($type, $resource_id, $reload = null)
    {
        return $this->vectorThumbnailAsyncWithHttpInfo($type, $resource_id, $reload)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vectorThumbnailAsyncWithHttpInfo
     *
     * Get Vector Thumbnail
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vectorThumbnailAsyncWithHttpInfo($type, $resource_id, $reload = null)
    {
        $returnType = 'string';
        $request = $this->vectorThumbnailRequest($type, $resource_id, $reload);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vectorThumbnail'
     *
     * @param  string $type Either dashboard or look (required)
     * @param  string $resource_id ID of the dashboard or look to render (required)
     * @param  string $reload Whether or not to refresh the rendered image with the latest content (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vectorThumbnailRequest($type, $resource_id, $reload = null)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling vectorThumbnail'
            );
        }
        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling vectorThumbnail'
            );
        }

        $resourcePath = '/vector_thumbnail/{type}/{resource_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($reload !== null) {
            $queryParams['reload'] = ObjectSerializer::toQueryValue($reload);
        }

        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resource_id' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['image/svg+xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['image/svg+xml'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
